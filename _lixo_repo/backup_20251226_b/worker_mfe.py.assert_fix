#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import os
import json
import csv
import requests
from datetime import datetime
from zoneinfo import ZoneInfo
import time

# ============================================================
# CONFIG
# ============================================================
TZ_NAME = os.getenv("APP_TZ", "America/Sao_Paulo")
TZ = ZoneInfo(TZ_NAME)

OUTPUT_JSON = os.getenv(
    "OUTPUT_JSON",
    os.path.join(os.path.dirname(__file__), "entrada.json")
)

MFE_CSV = os.getenv(
    "MFE_CSV",
    "/home/roteiro_ds/autotrader-planilhas-python/data/mfe_estudos.csv"
)

INTERVALO = int(os.getenv("INTERVALO", "300"))
RUN_ONCE = os.getenv("RUN_ONCE", "0") == "1"

# ============================================================
# UNIVERSO FIXO (77) — ORDEM ALFABÉTICA (como você passou)
# ============================================================
PARES = [
    "AAVE","ADA","APE","APT","AR","ARB","ATOM","AVAX","AXS","BAT","BCH","BLUR","BNB","BONK","BTC",
    "COMP","CRV","DASH","DGB","DENT","DOGE","DOT","EGLD","EOS","ETC","ETH","FET","FIL","FLOKI","FLOW",
    "FTM","GALA","GLM","GRT","HBAR","IMX","INJ","IOST","ICP","KAS","KAVA","KSM","LINK","LTC","MANA",
    "MATIC","MKR","NEO","NEAR","OMG","ONT","OP","ORDI","PEPE","QNT","QTUM","RNDR","ROSE","RUNE","SAND",
    "SEI","SHIB","SNX","SOL","STX","SUSHI","TIA","THETA","TRX","UNI","VET","XRP","XEM","XLM","XVS",
    "ZEC","ZRX"
]

# ============================================================
# PREÇOS (BULK) — CryptoCompare (USD)
# ============================================================
PRECO_CACHE = {}

def atualizar_precos_bulk(pares):
    """Busca preços em lote via CryptoCompare (USD) em pedaços (evita limite/URL grande)."""
    global PRECO_CACHE
    cache_final = {}

    try:
        CHUNK = 25
        for i in range(0, len(pares), CHUNK):
            parte = pares[i:i+CHUNK]
            fsyms = ",".join(parte)
            url = f"https://min-api.cryptocompare.com/data/pricemulti?fsyms={fsyms}&tsyms=USD"
            resp = requests.get(url, timeout=8).json()

            for sym in parte:
                v = resp.get(sym, {}).get("USD", 0)
                try:
                    cache_final[sym] = float(v) if v else 0.0
                except:
                    cache_final[sym] = 0.0

        PRECO_CACHE = cache_final
    except:
        PRECO_CACHE = {}

def preco_atual(par):
    return float(PRECO_CACHE.get(par, 0.0) or 0.0)

# ============================================================
# RISCO (por ativo) — simples e prático
# ============================================================
RISCO_BAIXO = {
    "BTC","ETH","BNB","XRP","ADA","SOL","DOGE","TRX","LTC","LINK","DOT","AVAX","ATOM","BCH"
}
RISCO_ALTO = {
    "PEPE","BONK","FLOKI","SHIB","DENT","DGB","IOST","ORDI"
}

def risco_por_ativo(par):
    if par in RISCO_BAIXO:
        return "BAIXO"
    if par in RISCO_ALTO:
        return "ALTO"
    return "MÉDIO"

# ============================================================
# CSV MFE — formato real: PAR;LADO;PERCENTIL;ALVO_PCT
# ============================================================
def ler_estudos_csv(caminho):
    estudos = {}
    with open(caminho, "r", encoding="utf-8") as f:
        leitor = csv.DictReader(f, delimiter=";")
        for row in leitor:
            par = (row.get("PAR") or "").strip().upper()
            lado = (row.get("LADO") or "").strip().upper()
            perc = (row.get("PERCENTIL") or "").strip()
            alvo = (row.get("ALVO_PCT") or "").strip()

            if not par or lado not in ("LONG", "SHORT"):
                continue
            if perc not in ("50", "60", "70"):
                continue
            try:
                alvo_f = float(alvo)
            except:
                continue

            estudos.setdefault(par, {}).setdefault(lado, {})[f"P{perc}"] = alvo_f
    return estudos

# ============================================================
# REGRAS
# ============================================================
def ganho_pct(preco, alvo, side):
    if preco <= 0 or alvo <= 0:
        return 0.0
    if side == "LONG":
        return max(0.0, ((alvo - preco) / preco) * 100.0)
    if side == "SHORT":
        return max(0.0, ((preco - alvo) / preco) * 100.0)
    return 0.0

def definir_zona(ganho):
    # mantido simples (você já aprovou as colunas)
    if ganho >= 6:
        return "VERDE"
    if ganho >= 3:
        return "AMARELA"
    return "VERMELHA"

def definir_prioridade(ganho):
    if ganho >= 8:
        return "ALTA"
    if ganho >= 5:
        return "MÉDIA"
    return "BAIXA"

def melhor_percentil_e_alvo(preco, data_lado, side):
    """
    P50/P60/P70 são % (ALVO_PCT).
    Regra PROFISSIONAL: escolher o MENOR percentil que já entrega GANHO >= 3%.
    Retorna (ganho, alvo_preco, "assertividade"=percentil escolhido 50/60/70).
    """
    candidatos = []
    for perc in ("P50","P60","P70"):
        pct = float(data_lado.get(perc, 0) or 0)
        if pct <= 0:
            continue

        if side == "LONG":
            alvo = preco * (1 + pct/100.0)
        else:
            alvo = preco * (1 - pct/100.0)

        g = ganho_pct(preco, alvo, side)
        candidatos.append((int(perc[1:]), g, alvo))

    if not candidatos:
        return (0.0, 0.0, 0)

    # ordenar por percentil (50 -> 70)
    candidatos.sort(key=lambda x: x[0])

    # pegar o primeiro que atende o filtro de 3%
    for perc_num, g, alvo in candidatos:
        if g >= 3:
            return (g, alvo, perc_num)

    # se nenhum atende, retorna o melhor ganho (só para diagnóstico)
    perc_num, g, alvo = max(candidatos, key=lambda x: x[1])
    return (g, alvo, perc_num)

def calcular_sinal(par, mfe):
    preco = preco_atual(par)
    if preco <= 0:
        return None

    long_data = mfe.get("LONG") or {}
    short_data = mfe.get("SHORT") or {}

    if not long_data and not short_data:
        return None

    gL, alvoL, aL = melhor_percentil_e_alvo(preco, long_data, "LONG") if long_data else (0.0, 0.0, 0)
    gS, alvoS, aS = melhor_percentil_e_alvo(preco, short_data, "SHORT") if short_data else (0.0, 0.0, 0)

    if gL <= 0 and gS <= 0:
        return None

    if gL >= gS:
        side, alvo, ganho, assertiv = "LONG", alvoL, gL, aL
    else:
        side, alvo, ganho, assertiv = "SHORT", alvoS, gS, aS

    # FILTRO ÚNICO: ganho mínimo 3% (como você pediu)
    if ganho < 3:
        return None

    agora = datetime.now(TZ)
    return {
        "par": par,
        "side": side,
        "preco": float(preco),
        "alvo": float(alvo),
        "ganho_pct": round(float(ganho), 2),
        "assertividade": float(assertiv),   # 50 / 60 / 70
        "zona": definir_zona(ganho),
        "risco": risco_por_ativo(par),
        "prioridade": definir_prioridade(ganho),
        "data": agora.strftime("%Y-%m-%d"),
        "hora": agora.strftime("%H:%M")
    }

# ============================================================
# LOOP
# ============================================================
def loop():
    print(f"[MFE] TZ={TZ_NAME} | OUTPUT_JSON={OUTPUT_JSON} | MFE_CSV={MFE_CSV}")
    while True:
        try:
            estudos = ler_estudos_csv(MFE_CSV)
            atualizar_precos_bulk(PARES)

            sinais = []
            for par in PARES:
                mfe = estudos.get(par)
                if not mfe:
                    continue
                s = calcular_sinal(par, mfe)
                if s:
                    sinais.append(s)

            # ORDEM: alfabética por PAR (como você pediu)
            sinais.sort(key=lambda x: x["par"])

            saida = {
                "posicional": sinais,
                "ultima_atualizacao": datetime.now(TZ).strftime("%Y-%m-%d %H:%M")
            }

            with open(OUTPUT_JSON, "w", encoding="utf-8") as f:
                json.dump(saida, f, indent=2, ensure_ascii=False)

            print(f"[OK] Atualizado: {saida['ultima_atualizacao']} | Total exibidas: {len(sinais)}")

        except Exception as e:
            print("ERRO NO LOOP:", e)

        if RUN_ONCE:
            break

        time.sleep(INTERVALO)

if __name__ == "__main__":
    loop()
