import os

def atomic_write_text(path_obj, text: str, encoding="utf-8"):
    """
    Escrita atômica: grava em .tmp e troca no final (os.replace).
    Evita o painel ficar vazio durante atualização.
    """
    from pathlib import Path
    path = Path(path_obj)
    tmp = path.with_name(path.name + ".tmp")
    tmp.write_text(text, encoding=encoding)
    os.replace(str(tmp), str(path))

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import os, json, csv, time, requests, tempfile


def _atomic_write_text(path: Path, text: str) -> None:
    tmp = path.with_name(path.name + ".tmp")
    _atomic_write_text(tmp, text, encoding="utf-8".split(', encoding=')[0] if False else text, encoding="utf-8")
    tmp.replace(path)
from datetime import datetime
from zoneinfo import ZoneInfo

TZ_NAME = os.getenv("APP_TZ", "America/Sao_Paulo")
TZ = ZoneInfo(TZ_NAME)

ROOT = os.path.dirname(__file__)
OUTPUT_JSON = os.getenv("OUTPUT_JSON", os.path.join(ROOT, "entrada.json"))
MFE_CSV = os.getenv("MFE_CSV", "/home/roteiro_ds/autotrader-planilhas-python/data/mfe_estudos.csv")
INTERVALO = int(os.getenv("INTERVALO", "300"))
RUN_ONCE = os.getenv("RUN_ONCE", "0") == "1"

GAIN_MIN = float(os.getenv("GAIN_MIN", "3.0"))  # filtro único
PRICE_CACHE_FILE = os.getenv("PRICE_CACHE_FILE", os.path.join(ROOT, "precos_cache.json"))

PARES = [
    "AAVE","ADA","APE","APT","AR","ARB","ATOM","AVAX","AXS","BAT","BCH","BLUR","BNB","BONK","BTC",
    "COMP","CRV","DASH","DGB","DENT","DOGE","DOT","EGLD","EOS","ETC","ETH","FET","FIL","FLOKI","FLOW",
    "FTM","GALA","GLM","GRT","HBAR","IMX","INJ","IOST","ICP","KAS","KAVA","KSM","LINK","LTC","MANA",
    "MATIC","MKR","NEO","NEAR","OMG","ONT","OP","ORDI","PEPE","QNT","QTUM","RNDR","ROSE","RUNE","SAND",
    "SEI","SHIB","SNX","SOL","STX","SUSHI","TIA","THETA","TRX","UNI","VET","XRP","XEM","XLM","XVS",
    "ZEC","ZRX"
]

PRECO_CACHE = {}

def load_preco_cache():
    global PRECO_CACHE
    try:
        if os.path.exists(PRICE_CACHE_FILE):
            with open(PRICE_CACHE_FILE, "r", encoding="utf-8") as f:
                data = json.load(f)
            if isinstance(data, dict):
                PRECO_CACHE = {k: float(v) for k, v in data.items() if v}
    except:
        pass

def save_preco_cache():
    try:
        tmp = PRICE_CACHE_FILE + ".tmp"
        with open(tmp, "w", encoding="utf-8") as f:
            json.dump(PRECO_CACHE, f, ensure_ascii=False)
        os.replace(tmp, PRICE_CACHE_FILE)
    except:
        pass

def atualizar_precos_bulk(pares):
    """
    Robusto:
    - tenta 3x
    - se falhar, mantém cache anterior (não zera)
    - se sucesso, salva cache em disco
    """
    global PRECO_CACHE
    cache_final = {}
    CHUNK = 25

    for tentativa in range(1, 4):
        try:
            cache_final = {}
            for i in range(0, len(pares), CHUNK):
                parte = pares[i:i+CHUNK]
                url = "https://min-api.cryptocompare.com/data/pricemulti"
                qs = {"fsyms": ",".join(parte), "tsyms": "USD"}
                resp = requests.get(url, params=qs, timeout=8).json()
                for sym in parte:
                    v = resp.get(sym, {}).get("USD", 0)
                    try:
                        cache_final[sym] = float(v) if v else 0.0
                    except:
                        cache_final[sym] = 0.0

            nonzero = sum(1 for v in cache_final.values() if v and v > 0)
            if nonzero < 10:
                raise RuntimeError(f"precos_insuficientes nonzero={nonzero}")

            PRECO_CACHE = cache_final
            save_preco_cache()
            return True
        except Exception as e:
            if tentativa == 3:
                return False
            time.sleep(0.6)

def preco_atual(par):
    try:
        return float(PRECO_CACHE.get(par, 0.0) or 0.0)
    except:
        return 0.0

def risco_por_ativo(par):
    baixo = {"BTC","ETH","BNB","XRP","ADA","SOL","DOGE","TRX","LTC","LINK","DOT","AVAX","ATOM","BCH"}
    alto  = {"PEPE","BONK","FLOKI","SHIB","DENT","DGB","IOST","ORDI"}
    if par in baixo: return "BAIXO"
    if par in alto:  return "ALTO"
    return "MÉDIO"

def peso_risco(risco):
    if risco == "BAIXO": return 1.00
    if risco == "MÉDIO": return 0.92
    return 0.82

def ler_estudos_csv(caminho):
    estudos = {}
    with open(caminho, "r", encoding="utf-8") as f:
        rd = csv.DictReader(f, delimiter=";")
        for r in rd:
            par = (r.get("PAR") or "").strip().upper()
            lado = (r.get("LADO") or "").strip().upper()
            perc = (r.get("PERCENTIL") or "").strip()
            alvo = (r.get("ALVO_PCT") or "").strip()
            if not par or lado not in ("LONG","SHORT") or perc not in ("50","60","70"):
                continue
            try:
                alvo_f = float(alvo)
            except:
                continue
            estudos.setdefault(par, {}).setdefault(lado, {})[f"P{perc}"] = alvo_f
    return estudos

def alvo_preco(preco, alvo_pct, side):
    if preco <= 0 or alvo_pct <= 0:
        return 0.0
    if side == "LONG":
        return preco * (1 + alvo_pct/100.0)
    return preco * (1 - alvo_pct/100.0)

def prob_atingir_pct(mfe_side, pct):
    p50 = float(mfe_side.get("P50", 0) or 0)
    p60 = float(mfe_side.get("P60", 0) or 0)
    p70 = float(mfe_side.get("P70", 0) or 0)

    if pct <= 0: return 100.0
    if p50 <= 0: return 0.0
    if p60 <= p50: p60 = p50
    if p70 <= p60: p70 = p60

    if pct <= p50:
        cdf = 0.5 * (pct / p50)
    elif pct <= p60:
        cdf = 0.5 + 0.1 * ((pct - p50) / (p60 - p50 + 1e-9))
    elif pct <= p70:
        cdf = 0.6 + 0.1 * ((pct - p60) / (p70 - p60 + 1e-9))
    else:
        cdf = min(0.95, 0.7 + 0.25 * ((pct - p70) / (p70 + 1e-9)))

    prob = max(0.0, 1.0 - cdf)
    return round(prob * 100.0, 2)

def zona_por_ganho(ganho):
    if ganho >= 6: return "VERDE"
    if ganho >= 3: return "AMARELA"
    return "VERMELHA"

def prioridade_por_ganho(ganho):
    if ganho >= 8: return "ALTA"
    if ganho >= 5: return "MÉDIA"
    return "BAIXA"

def calcular_sinal(par, mfe):
    preco = preco_atual(par)
    if preco <= 0:
        return None

    L = mfe.get("LONG") or {}
    S = mfe.get("SHORT") or {}
    if not L and not S:
        return None

    # P60 ESTRITO
    p60L = float(L.get("P60", 0) or 0)
    p60S = float(S.get("P60", 0) or 0)

    okL = p60L >= GAIN_MIN and p60L > 0
    okS = p60S >= GAIN_MIN and p60S > 0
    if not okL and not okS:
        return None

    risco = risco_por_ativo(par)
    w = peso_risco(risco)

    aL = prob_atingir_pct(L, GAIN_MIN) if okL else 0.0
    aS = prob_atingir_pct(S, GAIN_MIN) if okS else 0.0

    scoreL = (p60L * (aL/100.0) * w) if okL else 0.0
    scoreS = (p60S * (aS/100.0) * w) if okS else 0.0

    if okL and (not okS or scoreL >= scoreS):
        side, alvo_pct, ganho, assertiv, score = "LONG", p60L, p60L, aL, scoreL
    else:
        side, alvo_pct, ganho, assertiv, score = "SHORT", p60S, p60S, aS, scoreS

    alvo = alvo_preco(preco, alvo_pct, side)
    agora = datetime.now(TZ)

    return {
        "par": par,
        "side": side,
        "preco": float(preco),
        "alvo": float(alvo),
        "ganho_pct": round(float(ganho), 2),
        "assertividade": float(assertiv),
        "score": round(float(score), 4),
        "zona": zona_por_ganho(ganho),
        "risco": risco,
        "prioridade": prioridade_por_ganho(ganho),
        "data": agora.strftime("%Y-%m-%d"),
        "hora": agora.strftime("%H:%M")
    }

def write_json_atomic(path, obj):
    d = os.path.dirname(path) or "."
    fd, tmp = tempfile.mkstemp(prefix=".tmp_entrada_", dir=d)
    try:
        with os.fdopen(fd, "w", encoding="utf-8") as f:
            json.dump(obj, f, indent=2, ensure_ascii=False)
        os.replace(tmp, path)
    finally:
        try:
            if os.path.exists(tmp):
                os.remove(tmp)
        except:
            pass

def loop():
    load_preco_cache()
    print(f"[MFE] TZ={TZ_NAME} | OUTPUT_JSON={OUTPUT_JSON} | MFE_CSV={MFE_CSV} | GAIN_MIN={GAIN_MIN}")
    while True:
        try:
            estudos = ler_estudos_csv(MFE_CSV)

            ok_price = atualizar_precos_bulk(PARES)
            nonzero = sum(1 for v in PRECO_CACHE.values() if v and v > 0)

            if not ok_price and nonzero < 10:
                # Sem preços -> não sobrescreve o JSON bom
                print(f"[WARN] Falha preços (cache insuficiente). Mantendo último entrada.json. nonzero={nonzero}")
            else:
                sinais = []
                for par in PARES:
                    mfe = estudos.get(par)
                    if not mfe:
                        continue
                    s = calcular_sinal(par, mfe)
                    if s:
                        sinais.append(s)

                # rank por score
                rank_map = {}
                for i, it in enumerate(sorted(sinais, key=lambda x: x["score"], reverse=True), start=1):
                    rank_map[it["par"]] = i
                for it in sinais:
                    it["rank"] = rank_map.get(it["par"], 999)

                sinais.sort(key=lambda x: x["par"])

                saida = {
                    "posicional": sinais,
                    "ultima_atualizacao": datetime.now(TZ).strftime("%Y-%m-%d %H:%M")
                }
                write_json_atomic(OUTPUT_JSON, saida)
                print(f"[OK] Atualizado: {saida['ultima_atualizacao']} | Total exibidas: {len(sinais)}")

        except Exception as e:
            print("ERRO NO LOOP:", e)

        if RUN_ONCE:
            break
        time.sleep(INTERVALO)

if __name__ == "__main__":
    loop()
