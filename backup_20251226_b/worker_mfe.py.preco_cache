#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import os, json, csv, time, requests
from datetime import datetime
from zoneinfo import ZoneInfo

# ===== CONFIG =====
TZ_NAME = os.getenv("APP_TZ", "America/Sao_Paulo")
TZ = ZoneInfo(TZ_NAME)

OUTPUT_JSON = os.getenv("OUTPUT_JSON", os.path.join(os.path.dirname(__file__), "entrada.json"))
MFE_CSV = os.getenv("MFE_CSV", "/home/roteiro_ds/autotrader-planilhas-python/data/mfe_estudos.csv")
INTERVALO = int(os.getenv("INTERVALO", "300"))
RUN_ONCE = os.getenv("RUN_ONCE", "0") == "1"

GAIN_MIN = float(os.getenv("GAIN_MIN", "3.0"))  # filtro único

# ===== 77 MOEDAS =====
PARES = [
    "AAVE","ADA","APE","APT","AR","ARB","ATOM","AVAX","AXS","BAT","BCH","BLUR","BNB","BONK","BTC",
    "COMP","CRV","DASH","DGB","DENT","DOGE","DOT","EGLD","EOS","ETC","ETH","FET","FIL","FLOKI","FLOW",
    "FTM","GALA","GLM","GRT","HBAR","IMX","INJ","IOST","ICP","KAS","KAVA","KSM","LINK","LTC","MANA",
    "MATIC","MKR","NEO","NEAR","OMG","ONT","OP","ORDI","PEPE","QNT","QTUM","RNDR","ROSE","RUNE","SAND",
    "SEI","SHIB","SNX","SOL","STX","SUSHI","TIA","THETA","TRX","UNI","VET","XRP","XEM","XLM","XVS",
    "ZEC","ZRX"
]

# ===== PREÇOS (CryptoCompare USD) =====
PRECO_CACHE = {}

def atualizar_precos_bulk(pares):
    global PRECO_CACHE
    cache_final = {}
    try:
        CHUNK = 25
        for i in range(0, len(pares), CHUNK):
            parte = pares[i:i+CHUNK]
            url = "https://min-api.cryptocompare.com/data/pricemulti"
            qs = {"fsyms": ",".join(parte), "tsyms": "USD"}
            resp = requests.get(url, params=qs, timeout=8).json()

            for sym in parte:
                v = resp.get(sym, {}).get("USD", 0)
                try:
                    cache_final[sym] = float(v) if v else 0.0
                except:
                    cache_final[sym] = 0.0
        PRECO_CACHE = cache_final
    except:
        return  # mantém PRECO_CACHE anterior

def preco_atual(par):
    return float(PRECO_CACHE.get(par, 0.0) or 0.0)

# ===== RISCO =====
def risco_por_ativo(par):
    baixo = {"BTC","ETH","BNB","XRP","ADA","SOL","DOGE","TRX","LTC","LINK","DOT","AVAX","ATOM","BCH"}
    alto  = {"PEPE","BONK","FLOKI","SHIB","DENT","DGB","IOST","ORDI"}
    if par in baixo: return "BAIXO"
    if par in alto:  return "ALTO"
    return "MÉDIO"

def peso_risco(risco):
    # penaliza risco alto (melhor para resultado)
    if risco == "BAIXO": return 1.00
    if risco == "MÉDIO": return 0.92
    return 0.82

# ===== CSV MFE (PAR;LADO;PERCENTIL;ALVO_PCT) =====
def ler_estudos_csv(caminho):
    estudos = {}
    with open(caminho, "r", encoding="utf-8") as f:
        rd = csv.DictReader(f, delimiter=";")
        for r in rd:
            par = (r.get("PAR") or "").strip().upper()
            lado = (r.get("LADO") or "").strip().upper()
            perc = (r.get("PERCENTIL") or "").strip()
            alvo = (r.get("ALVO_PCT") or "").strip()
            if not par or lado not in ("LONG","SHORT") or perc not in ("50","60","70"):
                continue
            try:
                alvo_f = float(alvo)
            except:
                continue
            estudos.setdefault(par, {}).setdefault(lado, {})[f"P{perc}"] = alvo_f
    return estudos

# ===== CÁLCULOS =====
def alvo_preco(preco, alvo_pct, side):
    if preco <= 0 or alvo_pct <= 0:
        return 0.0
    if side == "LONG":
        return preco * (1 + alvo_pct/100.0)
    return preco * (1 - alvo_pct/100.0)

def prob_atingir_pct(mfe_side, pct):
    """
    Probabilidade (%) de MFE >= pct usando (0,0), (P50,0.5), (P60,0.6), (P70,0.7).
    Interpolação linear (sem inventar histórico).
    """
    p50 = float(mfe_side.get("P50", 0) or 0)
    p60 = float(mfe_side.get("P60", 0) or 0)
    p70 = float(mfe_side.get("P70", 0) or 0)

    if pct <= 0: return 100.0
    if p50 <= 0: return 0.0
    if p60 <= p50: p60 = p50
    if p70 <= p60: p70 = p60

    if pct <= p50:
        cdf = 0.5 * (pct / p50)
    elif pct <= p60:
        cdf = 0.5 + 0.1 * ((pct - p50) / (p60 - p50 + 1e-9))
    elif pct <= p70:
        cdf = 0.6 + 0.1 * ((pct - p60) / (p70 - p60 + 1e-9))
    else:
        cdf = min(0.95, 0.7 + 0.25 * ((pct - p70) / (p70 + 1e-9)))

    prob = max(0.0, 1.0 - cdf)
    return round(prob * 100.0, 2)

def zona_por_ganho(ganho):
    if ganho >= 6: return "VERDE"
    if ganho >= 3: return "AMARELA"
    return "VERMELHA"

def prioridade_por_ganho(ganho):
    if ganho >= 8: return "ALTA"
    if ganho >= 5: return "MÉDIA"
    return "BAIXA"

def calcular_sinal(par, mfe):
    preco = preco_atual(par)
    if preco <= 0:
        return None

    L = mfe.get("LONG") or {}
    S = mfe.get("SHORT") or {}
    if not L and not S:
        return None

    # P60 ESTRITO (se não tiver P60, não entra)
    p60L = float(L.get("P60", 0) or 0)
    p60S = float(S.get("P60", 0) or 0)

    okL = p60L >= GAIN_MIN and p60L > 0
    okS = p60S >= GAIN_MIN and p60S > 0
    if not okL and not okS:
        return None

    risco = risco_por_ativo(par)
    w = peso_risco(risco)

    # assert = chance de atingir pelo menos +3%
    aL = prob_atingir_pct(L, GAIN_MIN) if okL else 0.0
    aS = prob_atingir_pct(S, GAIN_MIN) if okS else 0.0

    # score = ganho * prob * peso risco
    scoreL = (p60L * (aL/100.0) * w) if okL else 0.0
    scoreS = (p60S * (aS/100.0) * w) if okS else 0.0

    if okL and (not okS or scoreL >= scoreS):
        side, alvo_pct, ganho, assertiv, score = "LONG", p60L, p60L, aL, scoreL
    else:
        side, alvo_pct, ganho, assertiv, score = "SHORT", p60S, p60S, aS, scoreS

    alvo = alvo_preco(preco, alvo_pct, side)
    agora = datetime.now(TZ)

    return {
        "par": par,
        "side": side,
        "preco": float(preco),
        "alvo": float(alvo),
        "ganho_pct": round(float(ganho), 2),      # = P60 (%)
        "alvo_pct": round(float(alvo_pct), 2),    # P60 (%)
        "assertividade": float(assertiv),         # chance de atingir +3%
        "score": round(float(score), 4),
        "zona": zona_por_ganho(ganho),
        "risco": risco,
        "prioridade": prioridade_por_ganho(ganho),
        "data": agora.strftime("%Y-%m-%d"),
        "hora": agora.strftime("%H:%M")
    }

def loop():
    print(f"[MFE] TZ={TZ_NAME} | OUTPUT_JSON={OUTPUT_JSON} | MFE_CSV={MFE_CSV} | GAIN_MIN={GAIN_MIN}")
    while True:
        try:
            estudos = ler_estudos_csv(MFE_CSV)
            atualizar_precos_bulk(PARES)

            sinais = []
            for par in PARES:
                mfe = estudos.get(par)
                if not mfe:
                    continue
                s = calcular_sinal(par, mfe)
                if s:
                    sinais.append(s)

            # rank por score (melhores oportunidades)
            rank_map = {}
            for i, it in enumerate(sorted(sinais, key=lambda x: x["score"], reverse=True), start=1):
                rank_map[it["par"]] = i
            for it in sinais:
                it["rank"] = rank_map.get(it["par"], 999)

            # lista continua A-Z (mas com rank pra você escolher)
            sinais.sort(key=lambda x: x["par"])

            saida = {"posicional": sinais, "ultima_atualizacao": datetime.now(TZ).strftime("%Y-%m-%d %H:%M")}
            with open(OUTPUT_JSON, "w", encoding="utf-8") as f:
                json.dump(saida, f, indent=2, ensure_ascii=False)

            print(f"[OK] Atualizado: {saida['ultima_atualizacao']} | Total exibidas: {len(sinais)}")
        except Exception as e:
            print("ERRO NO LOOP:", e)

        if RUN_ONCE:
            break
        time.sleep(INTERVALO)

if __name__ == "__main__":
    loop()
