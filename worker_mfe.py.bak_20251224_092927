#!/usr/bin/env python3
import json, time
from datetime import datetime
from zoneinfo import ZoneInfo
import ccxt

OUTPUT_JSON = "/home/roteiro_ds/ENTRADA-MFE/entrada.json"
TZ = ZoneInfo("America/Sao_Paulo")

# 77 moedas (mantive como estava no seu print)
COINS = [
  "AAVE","ADA","APE","APT","ARB","ATOM","AVAX","AXS","BAM","BCH","BLUR","BNB","BONK","BTC",
  "COMP","CRV","DASH","DGB","DENT","DOGE","DOT","EGLD","EOS","ETC","ETH","FET","FIL","FLOKI","FLOW",
  "FTM","GALA","GLM","GRT","HBAR","IMX","INJ","IOST","ICP","KAS","KAVA","KSM","LINK","LTC","MANA",
  "MATIC","MKR","NEO","NEAR","OMG","ONT","OP","ORDI","PEPE","QNT","QTUM","RNDR","ROSE","RUNE","SAND",
  "SEI","SHIB","SNX","SOL","STX","SUSHI","TIA","THETA","TRX","UNI","VET","XRP","XEM","XLM","XVS","ZEC","ZRX"
]

TIMEFRAME = "1d"
LIMIT = 120          # candles
RANGE_N = 90         # range p/ fibo
GANHO_MINIMO_PCT = 3.0

def round_price(x):
  try:
    return round(float(x), 6)
  except Exception:
    return None

def fib_zone(price, low, high):
  if price is None or low is None or high is None or high <= low:
    return "-"
  rng = high - low
  lv = {
    "0.236": high - rng*0.236,
    "0.382": high - rng*0.382,
    "0.500": high - rng*0.500,
    "0.618": high - rng*0.618,
    "0.786": high - rng*0.786,
  }
  # zonas (de cima p/ baixo)
  if price >= lv["0.236"]: return "0.000-0.236"
  if price >= lv["0.382"]: return "0.236-0.382"
  if price >= lv["0.500"]: return "0.382-0.500"
  if price >= lv["0.618"]: return "0.500-0.618"
  if price >= lv["0.786"]: return "0.618-0.786"
  return "0.786-1.000"

def decide(price, low, high):
  # regra simples só pra NÃO ficar vazio:
  # perto do topo -> SHORT; perto do fundo -> LONG; senão -> NÃO ENTRAR
  if price is None or low is None or high is None or high <= low:
    return ("NÃO ENTRAR", None, 0.0, "SEM DADOS", "BAIXO", "BAIXA")

  zona = fib_zone(price, low, high)

  # LONG quando estiver mais “embaixo” (zona >= 0.618-1.000)
  if zona in ["0.618-0.786", "0.786-1.000"]:
    alvo = high
    ganho = (alvo - price) / price * 100.0
    side = "LONG" if ganho >= GANHO_MINIMO_PCT else "NÃO ENTRAR"
    risco = "MÉDIO" if zona == "0.786-1.000" else "BAIXO"
    prioridade = "ALTA" if ganho >= 8 else ("MÉDIA" if ganho >= 5 else "BAIXA")
    return (side, alvo, ganho, zona, risco, prioridade)

  # SHORT quando estiver mais “em cima” (zona 0.000-0.382)
  if zona in ["0.000-0.236", "0.236-0.382"]:
    alvo = low
    ganho = (price - alvo) / price * 100.0
    side = "SHORT" if ganho >= GANHO_MINIMO_PCT else "NÃO ENTRAR"
    risco = "MÉDIO" if zona == "0.000-0.236" else "BAIXO"
    prioridade = "ALTA" if ganho >= 8 else ("MÉDIA" if ganho >= 5 else "BAIXA")
    return (side, alvo, ganho, zona, risco, prioridade)

  return ("NÃO ENTRAR", None, 0.0, zona, "BAIXO", "BAIXA")

def main_loop():
  print("Worker MFE iniciado…")
  ex = ccxt.binance({"enableRateLimit": True})
  ex.load_markets()

  while True:
    now = datetime.now(TZ)
    data = now.strftime("%Y-%m-%d")
    hora = now.strftime("%H:%M")

    rows = []
    for coin in COINS:
      par = coin
      symbol = f"{coin}/USDT"

      try:
        ohlcv = ex.fetch_ohlcv(symbol, timeframe=TIMEFRAME, limit=LIMIT)
        closes = [c[4] for c in ohlcv if c and len(c) >= 5]
        highs  = [c[2] for c in ohlcv[-RANGE_N:] if c and len(c) >= 3]
        lows   = [c[3] for c in ohlcv[-RANGE_N:] if c and len(c) >= 4]

        price = closes[-1] if closes else None
        high = max(highs) if highs else None
        low  = min(lows) if lows else None

        side, alvo, ganho, zona, risco, prioridade = decide(price, low, high)

        rows.append({
          "par": par,
          "side": side,
          "preco": round_price(price),
          "alvo": round_price(alvo) if alvo else None,
          "ganho_pct": round(float(ganho), 2),
          "zona": zona,
          "risco": risco,
          "prioridade": prioridade,
          "data": data,
          "hora": hora
        })

      except Exception as e:
        rows.append({
          "par": par,
          "side": "NÃO ENTRAR",
          "preco": None,
          "alvo": None,
          "ganho_pct": 0.0,
          "zona": "ERRO",
          "risco": "ALTO",
          "prioridade": "BAIXA",
          "data": data,
          "hora": hora,
          "erro": str(e)
        })

    payload = {
      "posicional": rows,
      "ultima_atualizacao": now.strftime("%Y-%m-%d %H:%M")
    }

    with open(OUTPUT_JSON, "w", encoding="utf-8") as f:
      json.dump(payload, f, ensure_ascii=False, indent=2)

    print(f"[OK] Atualizado: {payload['ultima_atualizacao']} | Total moedas: {len(rows)}")
    time.sleep(300)  # 5 minutos

if __name__ == "__main__":
  try:
    main_loop()
  except Exception as e:
    print("ERRO NO LOOP:", e)
